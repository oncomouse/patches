diff --git a/2bwm.c b/2bwm.c
index fdb5437..00e890d 100644
--- a/2bwm.c
+++ b/2bwm.c
@@ -21,6 +21,7 @@
 #include <unistd.h>
 #include <string.h>
 #include <signal.h>
+#include <sys/stat.h>
 #include <xcb/randr.h>
 #include <xcb/xcb_keysyms.h>
 #include <xcb/xcb_icccm.h>
@@ -49,6 +50,11 @@ static xcb_drawable_t dock_win=0;          // A single dock always on top.
 static struct item *winlist = NULL;        // Global list of all client windows.
 static struct item *monlist = NULL;        // List of all physical monitor outputs.
 static struct item *wslist[WORKSPACES];
+///---Autostart Globals---///
+static const char autostartblocksh[] = "autostart_blocking.sh";
+static const char autostartsh[] = "autostart.sh";
+static const char twobwmdir[] = "2bwm";
+static const char localshare[] = ".local/share";
 ///---Global configuration.---///
 static const char *atomnames[NB_ATOMS][1] = {
 	{"WM_DELETE_WINDOW"},
@@ -91,6 +97,7 @@ static void nextworkspace();
 static void getrandr(void);
 static void raise_current_window(void);
 static void raiseorlower();
+static void runautostart(void);
 static void setunfocus(void);
 static void maximize(const Arg *);
 static void fullscreen(const Arg *);
@@ -234,6 +241,83 @@ saveorigsize(struct client *client)
     client->origsize.height = client->height;
 }
 
+void
+runautostart(void)
+{
+	char *pathpfx;
+	char *path;
+	char *xdgdatahome;
+	char *home;
+	struct stat sb;
+
+	if ((home = getenv("HOME")) == NULL)
+		/* this is almost impossible */
+		return;
+
+	/* if $XDG_DATA_HOME is set and not empty, use $XDG_DATA_HOME/2bwm,
+	 * otherwise use ~/.local/share/2bwm as autostart script directory
+	 */
+	xdgdatahome = getenv("XDG_DATA_HOME");
+	if (xdgdatahome != NULL && *xdgdatahome != '\0') {
+		/* space for path segments, separators and nul */
+		pathpfx = calloc(1, strlen(xdgdatahome) + strlen(twobwmdir) + 2);
+
+		if (sprintf(pathpfx, "%s/%s", xdgdatahome, twobwmdir) <= 0) {
+			free(pathpfx);
+			return;
+		}
+	} else {
+		/* space for path segments, separators and nul */
+		pathpfx = calloc(1, strlen(home) + strlen(localshare)
+		                     + strlen(twobwmdir) + 3);
+
+		if (sprintf(pathpfx, "%s/%s/%s", home, localshare, twobwmdir) < 0) {
+			free(pathpfx);
+			return;
+		}
+	}
+
+	/* check if the autostart script directory exists */
+	if (! (stat(pathpfx, &sb) == 0 && S_ISDIR(sb.st_mode))) {
+		/* the XDG conformant path does not exist or is no directory
+		 * so we try ~/.2bwm instead
+		 */
+		char *pathpfx_new = realloc(pathpfx, strlen(home) + strlen(twobwmdir) + 3);
+		if(pathpfx_new == NULL) {
+			free(pathpfx);
+			return;
+		}
+		pathpfx = pathpfx_new;
+
+		if (sprintf(pathpfx, "%s/.%s", home, twobwmdir) <= 0) {
+			free(pathpfx);
+			return;
+		}
+	}
+
+	/* try the blocking script first */
+	path = calloc(1, strlen(pathpfx) + strlen(autostartblocksh) + 2);
+	if (sprintf(path, "%s/%s", pathpfx, autostartblocksh) <= 0) {
+		free(path);
+		free(pathpfx);
+	}
+
+	if (access(path, X_OK) == 0)
+		system(path);
+
+	/* now the non-blocking script */
+	if (sprintf(path, "%s/%s", pathpfx, autostartsh) <= 0) {
+		free(path);
+		free(pathpfx);
+	}
+
+	if (access(path, X_OK) == 0)
+		system(strcat(path, " &"));
+
+	free(pathpfx);
+	free(path);
+}
+
 void
 centerpointer(xcb_drawable_t win, struct client *cl)
 {
